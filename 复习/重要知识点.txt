# 题型
简答题 6x10
计算题 2x10
编程题 2x10

# 计算题
+ 3.1.2 周转时间和平均周转时间
+ 3.2.3 作业调度 FCFS SJF

+ 3.7 银行家算法

+ 4.3.4 动态内存分配 FirstFit BestFit WorstFit

+ 8.1.5 文件结构：Unix索引节点

## FCFS SJF
0  1  2  3  4    到达时间
4  3  1  2       执行时间
J1 J2 J3 J4

FCFS: J1 J2 J3 J4

  J1   J2   J3   J4
0    4    7    8    10

周转时间=结束时间-到达时间 >= 执行时间

    到达时间 开始时间 结束时间 周转时间
J1  0        0        4        4
J2  1        4        7        6
J3  2        7        8        6
J4  3        8        10       7

平均周转时间=(4+6+6+7)/4

SJF J1 J3 J4 J2
需要考虑：在当前已经到达的作业中选择最短的作业

时刻0：当前已经到达的作业包括 J1，作业 J3 最短但还没有到达
       只有1个候选，只能选择 J1
  J1
0    4

时刻4：当前已经到达的作业包括 J2、J3、J4，按照 SJF 排序 J3 J4 J2

  J1    J3   J4   J2
0    4     5    7   10

    到达时间 开始时间 结束时间 周转时间
J1  0        
J2  1        
J3  2        
J4  3        

平均周转时间=(4+4+5+7)/4

## 银行家算法 
初始状态
   Total Needed Allocated Rest(系统中剩余资源数量)
P1 3     1      2         1
P2 4     2      2
P3 5     3      2

安全状态：存在一个 序列：P1 P2 P3 的顺序申请资源，可以让所有进程执行完毕

P2 请求1个资源，系统满足它的要求，状态如下：
   Total Needed Allocated Rest(系统中剩余资源数量)
P1 3     1      2         0
P2 4     1      3
P3 5     3      2
此刻，P1/P2/P3 都无法继续执行，同时，它们又占着已经分配的资源不释放，系统死锁
P2 请求1个资源，系统就不应满足它的要求，如果满足请求，系统死锁

不安全状态：不存在一个 序列，可以让所有进程执行完毕

P1 请求1个资源，系统满足它的要求，状态如下：
   Total Needed Allocated Rest(系统中剩余资源数量)
P1 3     0      3         0
P2 4     2      2
P3 5     3      2

P1 执行完，归还已经分配的资源，状态如下：
   Total Needed Allocated Rest(系统中剩余资源数量)
P1 3     0      0         3
P2 4     2      2
P3 5     3      2

P2 执行完，归还已经分配的资源，状态如下：
   Total Needed Allocated Rest(系统中剩余资源数量)
P1 3     0      0         5
P2 4     0      0
P3 5     3      2

P3 执行完，归还已经分配的资源，状态如下：
   Total Needed Allocated Rest(系统中剩余资源数量)
P1 3     0      0         7
P2 4     0      0
P3 5     0      0

P1 请求1个资源，系统可以满足它的要求，系统不会死锁

问题：
(1) P1 请求1个资源，使用银行家算法，系统是否可以满足它的要求
(2) 在当前状态下，使用银行家算法，判断当前状态是否安全(不会导致死锁则为安全，会导致死锁则为不安全)

## 分配算法 FF WF BF
40 x 50 x 30 申请25

初始状态
区域1  40   低地址
区域2  50
区域3  30   高地址
总内存 120

申请大小为25内存, FirstFit，按地址顺序排序，从低到高查找，找到第一个可以满足的区域
区域1  40-25低地址
区域2  50
区域3  30   高地址

申请大小为25内存, WorstFit，按空闲块大小排序，在所有满足的区域中，找到最大的区域
区域1  40   低地址
区域2  50-25
区域3  30   高地址

申请大小为25内存, BestFit，按空闲块大小排序，在所有满足的区域中，找到最小的区域
区域1  40   低地址
区域2  50
区域3  30-25高地址

## UNIX 索引节点
FAT 不考核

## 只有主索引(一级索引)
+ 磁盘块的大小是 4096 字节，使用4个字节存储一个块号，一个磁盘能够存储 4096/4=1024个块号
+ 主索引占用一个磁盘块，它们存储的是块号
  - 主索引存储的块号，指向的是数据块(文件的内容)
+ 文件的索引，总共存储1024个数据块号
+ 如果采用一级索引，支持文件的最大尺寸为1024*4096

## 二级索引
书258页 图 8-7 
+ 磁盘块的大小是 4096 字节，使用4个字节存储一个块号，一个磁盘能够存储 4096/4=1024个块号
+ 主索引、二级索引本身也是占用一个磁盘块，它们存储的是块号
  - 主索引存储的块号，指向的是二级索引
  - 二级索引存储的块号，指向的是数据块(文件的内容)
+ 文件的索引，总共存储1024*1024个数据块号
+ 如果采用二级索引，支持文件的最大尺寸为1024*1024*4096

题目：
给定磁盘块的大小、每个块号占用空间的大小，采用二级索引，支持文件的最大尺寸

## 混合索引
书259页 图 8-8 

struct inode {
   int size;     // 文件大小
   int addr[13]; // 索引
};

+ 前10项是直接索引，存储的数据块（文件的内容），总共索引10个数据块
+ 第11项是一次间接索引，存储的索引块，总共索引1024个数据块
+ 第12项是二次间接索引，存储的索引块，总共索引1024*1024个数据块
+ 第13项是三次间接索引，存储的索引块，总共索引1024*1024*1024个数据块

支持文件的最大大小：(10+1024+1024*1024+1024*1024*1024)*4096

小文件，大小为 5000 个字节，占用2个数据块，使用直接索引就可以保存这2个数据块了

## 编程题

60页，生产者消费者问题程序
65页，读者写者问题程序